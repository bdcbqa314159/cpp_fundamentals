# Chapter 6 - Object Oriented Programming

## Introduction

We learned about templates that are used to create functions and classes that work with arbitrary types. This avoids duplication of work. However, using templates is not applicable in all cases, or may not be the best approach. The limitation of templates is that their types need to be known when the code is compiled.
In real-world cases, this is not always possible. A typical example would be a program that determines what logging infrastructure to use depending on the value of a configuration file.
We can solve these problems using the concept of inheritance in C++.

## Inheritance

Inheritance allows the combination of one or more classes.

```cpp
class Vehicle {
    public:
      TankLevel getTankLevel() const;
      void turnOn();
  };
  class Car : public Vehicle {
    public:
      bool isTrunkOpen();
  };
```

Here Vehicle is the base class and Car is the derived class.
When specifying the list of classes to derive from, we can also specify the visibility of the inheritance â€“ private, protected, or public.
The visibility modifier specifies who can know about the inheritance relationship between the classes.

When writing the constructor of the derived class, the compiler will implicitly call the default constructor of the base class before any initialization takes place.
If the base class does not have a default constructor but has a constructor that accepts parameters, then the derived class constructor can explicitly call it in the initialization list. Otherwise, there will be an error.

In a similar way to how the compiler calls the constructor of the base class when the derived class is constructed, the compiler takes care of always calling the destructor of the base class after the destructor of the derived class has run.

The copy constructor and the assignment operator generated by the compiler take care of calling the constructor and operator of the base class.

Note: In many compilers, you can enable additional warnings that notify you if you forget to add the calls to the base constructor.

It is important to understand that inheritance needs to model an is a relationship

Note: Using an is a test to understand whether a relationship can use inheritance can fail in some cases: for example, a square inheriting from a rectangle. When the width of the rectangle is doubled, the area of the rectangle doubles, but the area of the square quadruples. This means that code that expects to interact with rectangles might get surprising results when using a square, even if the square, mathematically, is a rectangle.

A more general rule is to use the Liskov Substitution Principle: if the A class inherits from B, we could replace the A class anywhere the B class is used, and the code would still behave correctly.

Up to now, we have seen examples of single inheritance: a derived class has a single base class. C++ supports multiple inheritance: a class can derive from multiple classes. Let's look at an example:

```cpp

struct A{};

struct B{};

struct C: A, B{};

```

The rules on how inheritance works are the same for single and multiple inheritance: the methods of all the derived classes are visible based on the visibility access specified, and we need to make sure to call the appropriate constructors and assign an operator for all of the base classes.

Note: It is usually best to have a shallow inheritance hierarchy: there should not be many levels of derived classes.

When using a multi-level inheritance hierarchy or multiple inheritance, it's more likely that you'll encounter some problems, such as ambiguous calls.

```cpp

struct A{
  void foo();
};

struct B{
  void foo();
};

struct C: A, B{
  void bar(){
    //foo(); is ambigous because the compiler can not decide which foo to call.
    A::foo();
    B::foo();
    //-> here we call one after the other invoking the right one.
  }
};

```