# Chapter 6 - Object Oriented Programming

## Introduction

We learned about templates that are used to create functions and classes that work with arbitrary types. This avoids duplication of work. However, using templates is not applicable in all cases, or may not be the best approach. The limitation of templates is that their types need to be known when the code is compiled.
In real-world cases, this is not always possible. A typical example would be a program that determines what logging infrastructure to use depending on the value of a configuration file.
We can solve these problems using the concept of inheritance in C++.

## Inheritance

Inheritance allows the combination of one or more classes.

```cpp
class Vehicle {
    public:
      TankLevel getTankLevel() const;
      void turnOn();
  };
  class Car : public Vehicle {
    public:
      bool isTrunkOpen();
  };
```

Here Vehicle is the base class and Car is the derived class.
When specifying the list of classes to derive from, we can also specify the visibility of the inheritance – private, protected, or public.
The visibility modifier specifies who can know about the inheritance relationship between the classes.

When writing the constructor of the derived class, the compiler will implicitly call the default constructor of the base class before any initialization takes place.
If the base class does not have a default constructor but has a constructor that accepts parameters, then the derived class constructor can explicitly call it in the initialization list. Otherwise, there will be an error.

In a similar way to how the compiler calls the constructor of the base class when the derived class is constructed, the compiler takes care of always calling the destructor of the base class after the destructor of the derived class has run.

The copy constructor and the assignment operator generated by the compiler take care of calling the constructor and operator of the base class.

Note: In many compilers, you can enable additional warnings that notify you if you forget to add the calls to the base constructor.

It is important to understand that inheritance needs to model an is a relationship

Note: Using an is a test to understand whether a relationship can use inheritance can fail in some cases: for example, a square inheriting from a rectangle. When the width of the rectangle is doubled, the area of the rectangle doubles, but the area of the square quadruples. This means that code that expects to interact with rectangles might get surprising results when using a square, even if the square, mathematically, is a rectangle.

A more general rule is to use the Liskov Substitution Principle: if the A class inherits from B, we could replace the A class anywhere the B class is used, and the code would still behave correctly.

Up to now, we have seen examples of single inheritance: a derived class has a single base class. C++ supports multiple inheritance: a class can derive from multiple classes. Let's look at an example:

```cpp

struct A{};

struct B{};

struct C: A, B{};

```

The rules on how inheritance works are the same for single and multiple inheritance: the methods of all the derived classes are visible based on the visibility access specified, and we need to make sure to call the appropriate constructors and assign an operator for all of the base classes.

Note: It is usually best to have a shallow inheritance hierarchy: there should not be many levels of derived classes.

When using a multi-level inheritance hierarchy or multiple inheritance, it's more likely that you'll encounter some problems, such as ambiguous calls.

```cpp

struct A{
  void foo();
};

struct B{
  void foo();
};

struct C: A, B{
  void bar(){
    //foo(); is ambigous because the compiler can not decide which foo to call.
    A::foo();
    B::foo();
    //-> here we call one after the other invoking the right one.
  }
};

```

## Polymorphism

Polymorphism means many forms and represents the ability of objects to behave in different ways.
We mentioned earlier that templates are a way to write code that works with many different types at compilation time and, depending on the types used to instantiate the template, the behavior will change.
This kind of pattern is called static polymorphism – static because it is known during compilation time. C++ also supports dynamic polymorphism – having the behavior of methods change while the program is running. This is powerful because we can react to information we obtain only after we have compiled our program, such as user input, values in configurations, or the kind of hardware the code is running on. This is possible thanks to two features – dynamic binding and dynamic dispatch.

### Dynamic Binding

Dynamic binding is the ability for a reference or a pointer of a base type to point to an object of a derived type at runtime.

```cpp
struct A{};

struct B:public A{};

struct C:public A{};

//We can write

B b;
C c;

A& ref1 = b;
A& ref2 = c;

A* p = nullptr;

if (run_time_condition) p = &b;
else p = &c;

```

Note: To allow dynamic binding, the code must know that the derived class derives from the base class.
If the inheritance's visibility is private, then only code inside the derived class will be able to bind the object to a pointer or reference of the base class.
If the inheritance is protected, then the derived class and every class deriving from it will be able to perform dynamic binding. Finally, if the inheritance is public, the dynamic binding will always be allowed.
This creates the distinction between the static type and the dynamic (or run-time) type. The static type is the type we can see in the source code. In this case, we can see that ref1 has a static type of a reference to the A struct.
The dynamic type is the real type of the object: the type that has been constructed in the object's memory location at runtime. For example, the static type of both ref1 and ref2 is a reference to the A struct, but the ref1 dynamic type is B, since ref1 refers to a memory location in which an object of type B has been created, and the ref2 dynamic type is C for the same reason.
It is important to understand that only references and pointers can be assigned values from a derived class safely. If we were to assign an object to a value type, we would get a surprising result – the object would get sliced.
We said earlier that a base class is embedded inside a derived class. Say, for example, we were to try and assign to a value, like so:

```cpp
B b;
A a = b;
```

The code would compile, but only the embedded part of A inside of B would be copied,
when we declare a variable of type A, the compiler dedicates an area of the memory big enough to contain an object of type A, so there cannot be enough space for B. When this happens, we say that we sliced the object, as we took only a part of the object when assigning or copying.
C++ supports dynamic dispatch. This is done by marking a method with a special keyword: virtual.
If a method is marked with the virtual keyword, when the method is called on a reference or a pointer, the compiler will execute the implementation of the dynamic type instead of the static type.

```cpp
void safeTurnOn(Vehicle& vehicle) {
    if (vehicle.getFuelInTank() > 0.1 && vehicle.batteryHasEnergy()) {
      vehicle.turnOn();
    }
}

//possible call
Car myCar;
Truck truck;
safeTurnOn(myCar);
safeTurnOn(truck);
```

A typical pattern is to create an interface that only specifies the methods that are
required for some functionality.
Classes that need to be used with such functionality must derive the interface and implement all the required methods.

## Virtual methods

In this section, we will take an in-depth look at how to tell the compiler to perform dynamic dispatch on a method. The way to specify that we want to use dynamic dispatch for a method is to use the virtual keyword.
The virtual keyword is used in front of a method when declaring it:

```cpp
class Vehicle {
    public:
      virtual void turnOn();
};
```
We need to remember that the compiler decides how to perform method dispatch based on the static type of the variable that is used when calling the method.
This means that we need to apply the virtual keyword to the type we are using in the code. Let's examine the following exercise to explore the virtual keyword.

When a method is declared virtual, we can override it in a derived class.
To override a method, we need to declare it with the same signature as the parent class: the same return type, name, parameters (including const-ness and ref-ness), const qualifier, and the other attributes.

If the signature does not match, we will create an overload for the function. The overload will be callable from the derived class, but it will never be executed with a dynamic dispatch from a base class, for example:

```cpp
struct Base {
    virtual void foo(int) = 0;
  };
  struct Derived: Base {
    /* This is an override: we are redefining a virtual method of the base
  class, using the same signature. */
    void foo(int) { }
/* This is an overload: we are defining a method with the same name of a method of the base class, but the signature is different. The rules regarding virtual do not apply between Base::foo(int) and Derived:foo(float). */
    void foo(float) {}
  };
```

When a class overrides a virtual method of the base class, the method of the most derived class will be executed when the method is called on a base class. This is true even if the method is called from inside the base class.
We can see a new keyword in the preceding example: the override keyword.
C++11 introduced this keyword to enable us to specify that we are overriding a method explicitly. This allows the compiler to give us an error message if we use the override keyword, but the signature does not match any base class' virtual method.

Note: Always use the override keyword when you are overriding a method. It is easy
to change the signature of the base class and forget to update all the locations where we overrode the method. If we do not update them, they will become a new overload instead of an override!

The virtual keyword can be applied to any method. Since the constructor is not a method, the constructor cannot be marked as virtual. Additionally, dynamic dispatch is disabled inside constructors and destructors.
The reason is that when constructing a hierarchy of derived classes, the constructor of the base class is executed before the constructor of the derived class. This means that if we were to call the virtual method on the derived class when constructing the base class, the derived class would not be initialized yet.
Similarly, when calling the destructor, the destructors of the whole hierarchy are executed in reverse order; first the derived and then the base class. Calling a virtual method in the destructor would call the method on a derived class that has already been destructed, which is an error.
While the constructor cannot be marked as virtual, the destructor can. If a class defines a virtual method, then it should also declare a virtual destructor.
Declaring a destructor virtual is extremely important when classes are created on dynamic memory, or the heap. We are going to see later in this chapter how to manage dynamic memory with classes, but for now, it is important to know that if a destructor is not declared virtual, then an object might be only partially destructed.

Note: If a method is marked virtual, then the destructor should also be marked virtual.

## Interfaces in C++

An interface is a way for the code to specify a contract that the caller needs to provide to be able to call some functionality. We looked at an informal definition when talking about the templates and the requirements they impose on the types used with them.
To specify an interface in C++, we can use an Abstract Base Class (ABC).
- Base: it is designed as a base class to be derived from.
- Abstract: it can not be instantiate.

Any class that defines a pure virtual method is abstract. A pure virtual method is a virtual method that ends with = 0, for example:

```cpp
class Vehicle{
  public:
  virtual void turnOn() = 0;
};

```

A pure virtual method is a method that does not have to be defined. Nowhere in the previous code have we specified the implementation of Vehicle::turnOn(). Because of this, the Vehicle class cannot be instantiated, as we do not have any code to call for its pure virtual methods.

We can instead derive from the class and override the pure virtual method. If a class derives from an abstract base class, it can be either of the following:

- Another abstract base class if it declares an additional pure virtual method, or if it does not override all the pure virtual methods of the base class

- A regular class if it overrides all the pure virtual methods of the base class

The same concept applies when a class is deriving from multiple abstract base classes: all the pure virtual methods of all the classes that need to be overridden in order to make the class concrete and thus instantiable.
While abstract base classes cannot be instantiated, we can define references and pointers to them.

Note: If you try to instantiate an abstract base class, the compiler will give an error specifying which methods are still pure virtual, thus making the class abstract.

Functions and methods that require specific methods can accept references and pointers to abstract base classes, and instances of concrete classes that derive from them can be bound to such references.

Since C++ does not provide a specialized keyword for defining interfaces and interfaces are simply abstract base classes, there are some guidelines that it's best practice to follow when designing an interface in C++:

- An abstract base class should not have any data members or fields.
The reason for this is that an interface specifies behavior, which should be independent of the data representation. It derives that abstract base classes should only have a default constructor.

- An abstract base class should always define a virtual destructor.
The definition of a destructor should be the default one: virtual ~Interface() = default. We are going to see why it is important for the destructor to be virtual later.

- All the methods of an abstract base class should be pure virtual.
The interface represents an expected functionality that needs to be implemented; a method which is not pure is an implementation. The implementation should be separate from the interface.

- All of the methods of an abstract base class should be public.
Similar to the previous point, we are defining a set of methods that we expect to call. We should not limit which classes can call the method only to classes deriving from the interface.

- All the methods of an abstract base class should be regarding a single functionality.
If our code requires multiple functionalities, separate interfaces can be created, and the class can derive from all of them. This allows us to compose interfaces more easily.

Consider disabling the copy and move constructors and assignment operators on the interface. Allowing the interface to be copied can cause the slicing problem we were describing before:

```cpp
Car redCar;
Car blueCar;
Vehicle& redVehicle = redCar;
Vehicle& redVehicle = blueCar;
redVehicle = blueVehicle;
// Problem: object slicing!
```

With the last assignment, we only copied the Vehicle part, since the copy constructor of the Vehicle class has been called. The copy constructor is not virtual, so the implementation in Vehicle is called, and since it only knows about the data members of the Vehicle class (which should be none), the ones defined inside Car have not been copied! This results in problems that are very hard to identify.
A possible solution is to disable the interface copy and move construct and assign operator: Interface(const Interface&) = delete; and similar. This has the drawback of disabling the compiler from creating the copy constructor and assign operators of the derived classes.
An alternative is to declare copy/move constructor/assignment protected so that only derived classes can call them, and we don't risk assigning interfaces while using them.

## Dynamic Memory

Dynamic memory is the part of the memory that the program can use to store objects, for which the program is responsible for maintaining the correct lifetime.
It is usually also called the heap and is often the alternative to the stack, which instead is handled automatically by the program. Dynamic memory can usually store much larger objects than the stack, which usually has a limit.

Let's start with an example: we want to write a function that will create a logger. When we execute tests, we create a logger specifically for the test called TestLogger, and when we run our program for users, we want to use a different logger, called ReleaseLogger.
We can see a good fit for interfaces here – we can write a logger abstract base class that defines all the methods needed for logging and have TestLogger and ReleaseLogger derive from it.
All our code will then use a reference to the logger when logging.

Given only an interface, we cannot know the size of the classes implementing it, since multiple classes could implement it and they could have different sizes. This prevents us from reserving some space in memory and passing a pointer to such space to the function, so that it could store the logger in it.
Since classes can have different sizes, the storage not only needs to remain valid longer than the function, but it also needs to be variable. That is dynamic memory!
In C++, there are two keywords to interact with dynamic memory – new and delete.

The new expression requests a piece of dynamic memory big enough to hold the object created and instantiates an object in that memory. It then returns a pointer to such an instance.

The delete keyword calls the destructor of the object pointed to by the pointer provided to it, and then gives the memory we initially requested back to the operating system.

If we forget to call the delete function on an object returned by calling the new function, we will have two major problems:

- The memory will not be returned to the operating system when we do not need it anymore. This is known as a memory leak. If this repeatedly happens during the execution of the program, our program will take more and more memory, until it consumes all the memory it can get.

- The destructor of the object will not be called.

If we do not call the destructor, we might not return some resources. For example, a connection to the database would be kept open, and our database would struggle due to too many connections being open, even if we are using only one.
The problem that arises if we call delete multiple times on the same pointer is that all the calls after the first one will access memory they should not be accessing.
The result can range from our program crashing to deleting other resources our program is currently using, resulting in incorrect behavior.
We can now see why it is extremely important to define a virtual destructor in the base class if we derive from it: we need to make sure that the destructor of the runtime
type is called when calling the delete function on the base object. If we call delete on a pointer to the base class while the runtime type is the derived class, we will only call the destructor of the base class and not fully destruct the derived class.
Making the destructor of the base class virtual will ensure that we are going to call the derived destructor, since we are using dynamic dispatch when calling it.

Note: For every call to the new operator, there must be exactly one call to delete with the pointer returned by new!

Note: For every call to new[], there must be exactly one call to delete[] with the pointer returned by new[].
The new operator and new[] function calls, and delete and delete[] function calls, cannot be intermixed. Always pair the ones for an array or the ones for single elements!

Dynamic memory is a powerful tool, but doing it manually is risky, error prone, and easy to get wrong.

Fortunately, modern C++ provides some facilities to make all this much easier to do. It is possible to write entire programs without ever using new and delete directly.

## Safe and Easy Dynamic Memory

We also saw how working with dynamic memory can be hard – we need to make sure to call new and delete in pairs, and failing to do so always has negative effects on our program. Fortunately for us, since C++11, there are tools in the standard library to help us overcome such limitations – smart pointers.
Smart pointers are types that behave like pointers, which are called raw pointers in this context, but have additional functionality.
We are going to look at two smart pointers from the standard library: std::unique_ptr and std::shared_ptr (read as unique pointer and shared pointer). Both pointers
are used to free the developer from the complexity of making sure to call delete appropriately.

They represent different ownership models. The owner of an object is the code that determines the lifetime of the object – the part of the code that decides when to create and when to destroy the object.

When managing objects in dynamic memory, ownership is not enforced by the compiler anymore, but it is helpful to apply the concept of ownership to the dynamic memory as well – the owner is who decides when to delete the object.

But the ownership of dynamic objects can also be passed around.
Smart pointers allow us to specify the ownership in the type of the pointer and make sure it is respected so that we do not have to keep track of it manually anymore.

Note: Always use smart pointers to represent the ownership of objects.
In a code base, smart pointers should be the pointers that control the lifetime of objects, and raw pointers, or regular pointers, are used only to reference objects.

### A Single Owner Using std::unique_ptr

The unique_ptr is the pointer type that's used by default. The unique pointer points to an object that has a single owner; there is a single place in the program that decides when to delete the object.
The unique pointer guarantees the uniqueness of ownership: the unique pointer cannot be copied. This means that once we have created a unique pointer for an object, there can be only one.

With the use of smart pointers, code bases should not use
new and delete anywhere. This is possible because the standard library, since C++14, offers a convenient function: std::make_unique. make_unique is a template function that takes the type of the object to create, and creates it in dynamic memory, passing its arguments to the object's constructor and returning a unique pointer to it.

```cpp
std::unique_ptr<Logger>createLogger() {
    if (are_tests_running()) {
      std::unique_ptr<TestLogger> logger = std::make_unique<TestLogger>();
       return logger; // logger is implicitly moved
} else {
      std::unique_ptr<ReleaseLogger> logger = std::make_
  unique<ReleaseLogger>("Release logger");
      return logger; // logger is implicitly moved
    }
}
```
There are three important points regarding this function:
- There is no longer a new expression in the body; it has been replaced with make_ unique. The make_unique function is simple to call because we can provide all
the arguments we would pass to the constructor of the type and have it created automatically.
- We are creating a unique_ptr to a derived class, but we are returning a unique_ptr to a base class.
Indeed, unique_ptr emulates the ability of raw pointers to convert pointers to derived classes to pointers to base classes. This makes using unique_ptr as simple as using raw pointers.
- We are using the move on the unique_ptr. As we said earlier, we cannot copy unique_ptr, but we are returning from a function, so we must use a value; otherwise, a reference would become invalid after the function returns, as we saw in Chapter 2, Functions.
While it cannot be copied, unique_ptr can be moved. When we move unique_ptr, we are transferring the ownership of the object to which it points to the recipient of the value. In this case, we are returning value, so we are transferring the ownership to the caller of the function.

Let's now see how we can rewrite the class that owns the number.

With raw pointers:

```cpp
class A {
      A() : number(new int(0)) {
      }
      ~A() {
          delete number;
      }
      int* number;
  };

```

With unique pointers:
```cpp
class A {
    A(): number(std::make_unique<int>()) {}
    std::unique_ptr<int> number;
};
```

Thanks to the fact that unique_ptr deletes the object automatically when it is destroyed, we did not have to write the destructor for the class, making our code even easier.
If we need to pass a pointer to the object, without transferring ownership, we can use the get() method on the raw pointer. Remember that raw pointers should not be used for ownership, and code accepting the raw pointer should never call delete on it.
Thanks to these features, unique_ptr should be the default choice to keep track of the ownership of an object.

### Shared Ownership using std::shared_pointer

The shared_ptr represents an object that has multiple owners: one out of several objects will
delete the owned object.
An example could make a TCP connection, which is established by multiple threads to send data. Each thread uses the TCP connection to send data and then terminates.

shared_ptr can be used in such situations: shared_ptr can be copied many times, and the object pointed to by the pointer will remain alive until the last shared_ptr is destroyed. We guarantee that the object remains valid as long as there is at least one shared_ptr instance pointing to it.

One question arises: what happens if node A is connected to node B and node B is connected to node A?
Both nodes have a shared_ptr instance to the other, and even if no other node has a connection to them, they will remain alive because a shared_ptr instance to them exists. This is an example of circular dependency.
When using shared pointers, we must pay attention to these cases. The standard library offers a different kind of pointer to handle these situations: std::weak_ptr (read as weak pointer).
weak_ptr is a smart pointer that can be used in conjunction with shared_ptr to solve the circular dependencies that might happen in our programs.
Generally, shared_ptr is enough to model most cases where unique_ptr does not work, and together they cover the majority of the uses of dynamic memory in a code base.

## Summary

In this chapter, we saw how inheritance can be used to combine classes in C++. We saw what a base class is and what a derived class is, how to write a class that derives from another, and how to control the visibility modifier. We talked about how to initialize a base class in a derived one by calling the base class constructor.
We then explained polymorphism and the ability of C++ to dynamically bind a pointer or reference of a derived class to a pointer or reference of the base class. We explained what dispatch for functions is, how it works statically by default, and how we can make it dynamic with the use of the virtual keyword. Following that, we explored how to properly write virtual functions and how we can override them, making sure to mark such overrode functions with the override keyword.
Next, we showed how to define interfaces with abstract base classes and how to use pure virtual methods. We also provided guidelines on how to correctly define interfaces.
Lastly, we delved into dynamic memory and what problems it solves, but we also saw
how easy it is to use it incorrectly.
We concluded the chapter by showing how modern C++ makes using dynamic memory painless by providing smart pointers that handle complex details for us: unique_ptr
to manage objects with a single owner, and shared_ptr for objects owned by multiple objects.
All these tools can be effective at writing solid programs that can be effectively evolved and maintained, while retaining the performance C++ is famous for.


