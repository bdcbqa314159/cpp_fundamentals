# Chapter 6 - Object Oriented Programming

## Introduction

We learned about templates that are used to create functions and classes that work with arbitrary types. This avoids duplication of work. However, using templates is not applicable in all cases, or may not be the best approach. The limitation of templates is that their types need to be known when the code is compiled.
In real-world cases, this is not always possible. A typical example would be a program that determines what logging infrastructure to use depending on the value of a configuration file.
We can solve these problems using the concept of inheritance in C++.

## Inheritance

Inheritance allows the combination of one or more classes.

```cpp
class Vehicle {
    public:
      TankLevel getTankLevel() const;
      void turnOn();
  };
  class Car : public Vehicle {
    public:
      bool isTrunkOpen();
  };
```

Here Vehicle is the base class and Car is the derived class.
When specifying the list of classes to derive from, we can also specify the visibility of the inheritance – private, protected, or public.
The visibility modifier specifies who can know about the inheritance relationship between the classes.

When writing the constructor of the derived class, the compiler will implicitly call the default constructor of the base class before any initialization takes place.
If the base class does not have a default constructor but has a constructor that accepts parameters, then the derived class constructor can explicitly call it in the initialization list. Otherwise, there will be an error.

In a similar way to how the compiler calls the constructor of the base class when the derived class is constructed, the compiler takes care of always calling the destructor of the base class after the destructor of the derived class has run.

The copy constructor and the assignment operator generated by the compiler take care of calling the constructor and operator of the base class.

Note: In many compilers, you can enable additional warnings that notify you if you forget to add the calls to the base constructor.

It is important to understand that inheritance needs to model an is a relationship

Note: Using an is a test to understand whether a relationship can use inheritance can fail in some cases: for example, a square inheriting from a rectangle. When the width of the rectangle is doubled, the area of the rectangle doubles, but the area of the square quadruples. This means that code that expects to interact with rectangles might get surprising results when using a square, even if the square, mathematically, is a rectangle.

A more general rule is to use the Liskov Substitution Principle: if the A class inherits from B, we could replace the A class anywhere the B class is used, and the code would still behave correctly.

Up to now, we have seen examples of single inheritance: a derived class has a single base class. C++ supports multiple inheritance: a class can derive from multiple classes. Let's look at an example:

```cpp

struct A{};

struct B{};

struct C: A, B{};

```

The rules on how inheritance works are the same for single and multiple inheritance: the methods of all the derived classes are visible based on the visibility access specified, and we need to make sure to call the appropriate constructors and assign an operator for all of the base classes.

Note: It is usually best to have a shallow inheritance hierarchy: there should not be many levels of derived classes.

When using a multi-level inheritance hierarchy or multiple inheritance, it's more likely that you'll encounter some problems, such as ambiguous calls.

```cpp

struct A{
  void foo();
};

struct B{
  void foo();
};

struct C: A, B{
  void bar(){
    //foo(); is ambigous because the compiler can not decide which foo to call.
    A::foo();
    B::foo();
    //-> here we call one after the other invoking the right one.
  }
};

```

## Polymorphism

Polymorphism means many forms and represents the ability of objects to behave in different ways.
We mentioned earlier that templates are a way to write code that works with many different types at compilation time and, depending on the types used to instantiate the template, the behavior will change.
This kind of pattern is called static polymorphism – static because it is known during compilation time. C++ also supports dynamic polymorphism – having the behavior of methods change while the program is running. This is powerful because we can react to information we obtain only after we have compiled our program, such as user input, values in configurations, or the kind of hardware the code is running on. This is possible thanks to two features – dynamic binding and dynamic dispatch.

### Dynamic Binding

Dynamic binding is the ability for a reference or a pointer of a base type to point to an object of a derived type at runtime.

```cpp
struct A{};

struct B:public A{};

struct C:public A{};

//We can write

B b;
C c;

A& ref1 = b;
A& ref2 = c;

A* p = nullptr;

if (run_time_condition) p = &b;
else p = &c;

```

Note: To allow dynamic binding, the code must know that the derived class derives from the base class.
If the inheritance's visibility is private, then only code inside the derived class will be able to bind the object to a pointer or reference of the base class.
If the inheritance is protected, then the derived class and every class deriving from it will be able to perform dynamic binding. Finally, if the inheritance is public, the dynamic binding will always be allowed.
This creates the distinction between the static type and the dynamic (or run-time) type. The static type is the type we can see in the source code. In this case, we can see that ref1 has a static type of a reference to the A struct.
The dynamic type is the real type of the object: the type that has been constructed in the object's memory location at runtime. For example, the static type of both ref1 and ref2 is a reference to the A struct, but the ref1 dynamic type is B, since ref1 refers to a memory location in which an object of type B has been created, and the ref2 dynamic type is C for the same reason.
It is important to understand that only references and pointers can be assigned values from a derived class safely. If we were to assign an object to a value type, we would get a surprising result – the object would get sliced.
We said earlier that a base class is embedded inside a derived class. Say, for example, we were to try and assign to a value, like so:

```cpp
B b;
A a = b;
```

The code would compile, but only the embedded part of A inside of B would be copied,
when we declare a variable of type A, the compiler dedicates an area of the memory big enough to contain an object of type A, so there cannot be enough space for B. When this happens, we say that we sliced the object, as we took only a part of the object when assigning or copying.
C++ supports dynamic dispatch. This is done by marking a method with a special keyword: virtual.
If a method is marked with the virtual keyword, when the method is called on a reference or a pointer, the compiler will execute the implementation of the dynamic type instead of the static type.

```cpp
void safeTurnOn(Vehicle& vehicle) {
    if (vehicle.getFuelInTank() > 0.1 && vehicle.batteryHasEnergy()) {
      vehicle.turnOn();
    }
}

//possible call
Car myCar;
Truck truck;
safeTurnOn(myCar);
safeTurnOn(truck);
```

A typical pattern is to create an interface that only specifies the methods that are
required for some functionality.
Classes that need to be used with such functionality must derive the interface and implement all the required methods.

## Virtual methods

In this section, we will take an in-depth look at how to tell the compiler to perform dynamic dispatch on a method. The way to specify that we want to use dynamic dispatch for a method is to use the virtual keyword.
The virtual keyword is used in front of a method when declaring it:

```cpp
class Vehicle {
    public:
      virtual void turnOn();
};
```
We need to remember that the compiler decides how to perform method dispatch based on the static type of the variable that is used when calling the method.
This means that we need to apply the virtual keyword to the type we are using in the code. Let's examine the following exercise to explore the virtual keyword.

When a method is declared virtual, we can override it in a derived class.
To override a method, we need to declare it with the same signature as the parent class: the same return type, name, parameters (including const-ness and ref-ness), const qualifier, and the other attributes.

If the signature does not match, we will create an overload for the function. The overload will be callable from the derived class, but it will never be executed with a dynamic dispatch from a base class, for example:

```cpp
struct Base {
    virtual void foo(int) = 0;
  };
  struct Derived: Base {
    /* This is an override: we are redefining a virtual method of the base
  class, using the same signature. */
    void foo(int) { }
/* This is an overload: we are defining a method with the same name of a method of the base class, but the signature is different. The rules regarding virtual do not apply between Base::foo(int) and Derived:foo(float). */
    void foo(float) {}
  };
```

When a class overrides a virtual method of the base class, the method of the most derived class will be executed when the method is called on a base class. This is true even if the method is called from inside the base class.
We can see a new keyword in the preceding example: the override keyword.
C++11 introduced this keyword to enable us to specify that we are overriding a method explicitly. This allows the compiler to give us an error message if we use the override keyword, but the signature does not match any base class' virtual method.

Note: Always use the override keyword when you are overriding a method. It is easy
to change the signature of the base class and forget to update all the locations where we overrode the method. If we do not update them, they will become a new overload instead of an override!

The virtual keyword can be applied to any method. Since the constructor is not a method, the constructor cannot be marked as virtual. Additionally, dynamic dispatch is disabled inside constructors and destructors.
The reason is that when constructing a hierarchy of derived classes, the constructor of the base class is executed before the constructor of the derived class. This means that if we were to call the virtual method on the derived class when constructing the base class, the derived class would not be initialized yet.
Similarly, when calling the destructor, the destructors of the whole hierarchy are executed in reverse order; first the derived and then the base class. Calling a virtual method in the destructor would call the method on a derived class that has already been destructed, which is an error.
While the constructor cannot be marked as virtual, the destructor can. If a class defines a virtual method, then it should also declare a virtual destructor.
Declaring a destructor virtual is extremely important when classes are created on dynamic memory, or the heap. We are going to see later in this chapter how to manage dynamic memory with classes, but for now, it is important to know that if a destructor is not declared virtual, then an object might be only partially destructed.

Note: If a method is marked virtual, then the destructor should also be marked virtual.

## Interfaces in C++

An interface is a way for the code to specify a contract that the caller needs to provide to be able to call some functionality. We looked at an informal definition when talking about the templates and the requirements they impose on the types used with them.
To specify an interface in C++, we can use an Abstract Base Class (ABC).
- Base: it is designed as a base class to be derived from.
- Abstract: it can not be instantiate.

Any class that defines a pure virtual method is abstract. A pure virtual method is a virtual method that ends with = 0, for example:

```cpp
class Vehicle{
  public:
  virtual void turnOn() = 0;
};

```


A pure virtual method is a method that does not have to be defined. Nowhere in the previous code have we specified the implementation of Vehicle::turnOn(). Because of this, the Vehicle class cannot be instantiated, as we do not have any code to call for its pure virtual methods.

We can instead derive from the class and override the pure virtual method. If a class derives from an abstract base class, it can be either of the following:

- Another abstract base class if it declares an additional pure virtual method, or if it does not override all the pure virtual methods of the base class

- A regular class if it overrides all the pure virtual methods of the base class

The same concept applies when a class is deriving from multiple abstract base classes: all the pure virtual methods of all the classes that need to be overridden in order to make the class concrete and thus instantiable.
While abstract base classes cannot be instantiated, we can define references and pointers to them.

Note: If you try to instantiate an abstract base class, the compiler will give an error specifying which methods are still pure virtual, thus making the class abstract.

Functions and methods that require specific methods can accept references and pointers to abstract base classes, and instances of concrete classes that derive from them can be bound to such references.

Since C++ does not provide a specialized keyword for defining interfaces and interfaces are simply abstract base classes, there are some guidelines that it's best practice to follow when designing an interface in C++:

- An abstract base class should not have any data members or fields.
The reason for this is that an interface specifies behavior, which should be independent of the data representation. It derives that abstract base classes should only have a default constructor.

- An abstract base class should always define a virtual destructor.
The definition of a destructor should be the default one: virtual ~Interface() = default. We are going to see why it is important for the destructor to be virtual later.

- All the methods of an abstract base class should be pure virtual.
The interface represents an expected functionality that needs to be implemented; a method which is not pure is an implementation. The implementation should be separate from the interface.

- All of the methods of an abstract base class should be public.
Similar to the previous point, we are defining a set of methods that we expect to call. We should not limit which classes can call the method only to classes deriving from the interface.

- All the methods of an abstract base class should be regarding a single functionality.
If our code requires multiple functionalities, separate interfaces can be created, and the class can derive from all of them. This allows us to compose interfaces more easily.

Consider disabling the copy and move constructors and assignment operators on the interface. Allowing the interface to be copied can cause the slicing problem we were describing before:

```cpp
Car redCar;
Car blueCar;
Vehicle& redVehicle = redCar;
Vehicle& redVehicle = blueCar;
redVehicle = blueVehicle;
// Problem: object slicing!
```

With the last assignment, we only copied the Vehicle part, since the copy constructor of the Vehicle class has been called. The copy constructor is not virtual, so the implementation in Vehicle is called, and since it only knows about the data members of the Vehicle class (which should be none), the ones defined inside Car have not been copied! This results in problems that are very hard to identify.
A possible solution is to disable the interface copy and move construct and assign operator: Interface(const Interface&) = delete; and similar. This has the drawback of disabling the compiler from creating the copy constructor and assign operators of the derived classes.
An alternative is to declare copy/move constructor/assignment protected so that only derived classes can call them, and we don't risk assigning interfaces while using them.

